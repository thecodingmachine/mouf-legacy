<h1>Managing URL parameters</h1>

<h2>Default behaviour</h2>

<p>By default, when an action is created, each parameter of the function should be passed in the URL. Here is a sample:</p>

<pre>
/**
 * My action with 2 compulsory parameters.
 *
 * @Action
 * @param string $var1
 * @param string $var2
 */
public function my_action($var1, $var2) { ... } 
</pre>

<p>In this action, both parameters are compulsory. If one of the parameters is not passed by the user, an error message is displayed.</p>
<p>Hopefully, you can get optional parameters using parameters default values:</p>

<pre>
/**
 * My action with 1 compulsory parameter and one optional.
 *
 * @Action
 * @param string $var1
 * @param string $var2
 */
public function my_action($var1, $var2 = 42) { ... } 
</pre>

<p>In this sample, if the user does not pass the "var2" parameter in the URL, it will be equal to 42.</p>
<p>The URL might be: <code>http://[server-url]/[webapp-path]/my_controller/my_action?var1=param1</code></p>

<h2>Advanced behaviour</h2>

<h3>Parameters' origin</h3>
<p>In an action, you can pass additional annotations in order to modify the default mapping of parameters.</p>
<p>Here is a sample:</p>
<pre>
/**
 * My action with 1 compulsory parameter and one optional.
 *
 * @Action
 * @param int $userId (origin="request[user_id]")
 */
public function my_action($userId) { ... } 
</pre>

<p>The <code>@param</code> annotation is used to modify the default mapping.</p>
<p>The line <code>@param in $userI (origin="request[user_id]")</code> means:<br/>
Map argument "$userId" in the action to request parameter user_id, and must be an int value. Therefore, the URL to access the page will be: <code>http://[server-url]/[webapp-path]/my_controller/my_action?user_id=12</code></p>

<p>The "origin" in @param annotation can be:</p>
<ul>
  <li><b>request</b> (for instance: <code>@param int $userId (origin="request[user_id]")</code>). Get the parameter from the request</li>
  <li><b>session</b> (for instance: <code>@param int $userId (origin="session[user_id]")</code>). Get the parameter from the session</li>
  <li><b>url</b> (for instance: <code>@param int $userId (origin="url[0]")</code>). Get the parameter from the path in the URL. For instance, if the path is <code>http://[server-url]/[webapp-path]/my_controller/my_action/42</code>, the $userId will be 42.</li>
</ul>

<p>You can also chain several origins. For instance:<br/>
<code>@param int $userId (origin="request[user_id]/session[user_id]")</code> will fetch the result from the user_id parameter in the request. If no such parameter exist, it will try
to fetch the parameter from the session.</p>

<h3>Parameters' type</h3>
<p>
In classic PHP behaviour, you the <code>@param [type] $var</code> annotation only informs the user of the expected type of the parameter.
Using Splash, this annotation means a lot more because Splash will throw an Excpetion if the variable as an unexepted type.
For example, if you use the annotation @param int $userId, and the variable is in fact a string ('toto' for instance).
</p>
<p>
Possible types can be one of:
	<ul>
		<li>string</li>
		<li>int</li>
		<li>float</li>
		<li>bool</li>
		<li>array</li>
	</ul>
</p>

<h3>Validators</h3>

<p>Splash can also provide validators for each parameters. A validator is a piece of code that will check the format of a parameter.
For instance, you can check that a parameter is a number or that a parameter is an e-mail address.</p>

<p>Note: with the current version, if a parameter is not valid, an error screen is displayed. You cannot catch this error to provide custom behaviour in the current version.</p>

<pre>
/**
 * @Action
 * @param string $email (origin="request[user_email]", validator="Email")
 */
public function sendMail($email) { ... }
</pre>

<p>In the sample above, the "user_email" parameter passed by the web page must be an Email.</p>

<p>Splash provides two filters:</p>
<ul>
  <li>Number: validates the value is a number</li>
  <li>Email: validates the value is an email address</li>
</ul>
<p>You can provide your own validators by extending the ValidatorInterface.</p>
<p>
<b><u>Note:</u></b> In the previous version of Splash, the annotation @param was replaced by the @Var annotation, for instance:
<pre>@Var{email}(origin="request[user_email]", validator="Email")</pre>
<em>
As you see, the only differences are:
<ul><li><code>@param</code> is part of the PHP Doc autogenerated comments</li>
<li>you no longer write the variable <code>{var_name}</code>, but <code>$var_name</code> directly</li>
<li>there is a space between variabme name and optional Origin and Validator settings.</li>
</ul>
</em>
</p>