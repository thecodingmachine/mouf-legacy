<?php
require_once dirname(__FILE__)."/../../../../../mouf/MoufPackageManager.php";

/**
 * This class generates automatically DAOs and Beans for TDBM.
 *
 */
class TDBMDaoGenerator {

	/**
	 * 
	 * @var DB_ConnectionInterface
	 */
	private $dbConnection;
	
	private $daoFactoryClassName;
	
	/**
	 * Constructor.
	 *
	 * @param DB_ConnectionInterface $dbConnection The connection to the database.
	 */
	public function __construct(DB_ConnectionInterface $dbConnection, $daoFactoryClassName) {
		$this->dbConnection = $dbConnection;
		$this->daoFactoryClassName = $daoFactoryClassName;
	}
	
	/**
	 * Generates all the daos and beans.
	 */
	public function generateAllDaosAndBeans() {
		// TODO: check that no class name ends with "Base". Otherwise, there will be name clash.
		$tableList = $this->dbConnection->getListOfTables();
		
		foreach ($tableList as $table) {
			$this->generateDaoAndBean($table);
		}
		
		$this->generateFactory($tableList);

		// Ok, let's return the list of all tables.
		// These will be used by the calling script to create Mouf instances.
		$root = simplexml_load_string("<tdbm></tdbm>");
    	foreach ($tableList as $table) {
    		$root->addChild("table", $table);
    	}
		
		return $root;
	}
	
	/**
	 * Generates in one method call the daos and the beans for one table.
	 * 
	 * @param $tableName
	 */
	public function generateDaoAndBean($tableName) {
		//$baseClassName = TDBMDaoGenerator::toSingular(TDBMDaoGenerator::toCamelCase($tableName));
		$daoName = $this->getDaoNameFromTableName($tableName);
		$beanName = $this->getBeanNameFromTableName($tableName);
		$baseBeanName = $this->getBaseBeanNameFromTableName($tableName);
		$beanDirectory = dirname(__FILE__)."/../../../../../dao/beans/";
		$daoDirectory = dirname(__FILE__)."/../../../../../dao/";
		if (!file_exists($beanDirectory)) {
			$result = mkdir($beanDirectory, 0777, true);
			if ($result == false) {
				echo "Unable to create directory: ".$beanDirectory.".";
				exit;
			}
		}
		
		$this->generateBean($beanDirectory, $beanName.".php", $beanName, $baseBeanName.".php", $baseBeanName, $tableName);
		$this->generateDao($daoDirectory, $daoName.".php", $daoName."Base.php", $beanName.".php", $daoName, $daoName."Base", $beanName, $tableName);
	}
	
	/**
	 * Returns the name of the bean class from the table name.
	 * 
	 * @param $tableName
	 * @return string
	 */
	public function getBeanNameFromTableName($tableName) {
		return TDBMDaoGenerator::toSingular(TDBMDaoGenerator::toCamelCase($tableName))."Bean";
	}
	
	/**
	 * Returns the name of the base bean class from the table name.
	 * 
	 * @param $tableName
	 * @return string
	 */
	public function getDaoNameFromTableName($tableName) {
		return TDBMDaoGenerator::toSingular(TDBMDaoGenerator::toCamelCase($tableName))."Dao";
	}
	
	/**
	 * Returns the name of the DAO class from the table name.
	 * 
	 * @param $tableName
	 * @return string
	 */
	public function getBaseBeanNameFromTableName($tableName) {
		return TDBMDaoGenerator::toSingular(TDBMDaoGenerator::toCamelCase($tableName))."BaseBean";
	}
	
	/**
	 * Writes the PHP bean file with all getters and setters from the table passed in parameter.
	 *
	 * @param string $directory The directory in which files should be written. It should end with /.
	 * @param string $fileName The file that will be written (name only, no directory)
	 * @param string $className The name of the class
	 * @param string $baseFileName The name of the base class file which contains the base file which will be extended (name only, no directory)
	 * @param string $baseClassName The name of the base class which will be extended (name only, no directory)
	 * @param string $tableName The name of the table
	 */	
	public function generateBean($directory, $fileName, $className, $baseFileName, $baseClassName, $tableName) {
		//$tableInfo = $this->dbConnection->getTableInfo($tableName);
		$table = $this->dbConnection->getTableFromDbModel($tableName);

		// List of methods already written.
		$methodsList = array();
		
		$str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * DO NOT edit this file, as it might be overwritten.
 * If you need to perform changes, edit the $className class instead!
 */

/**
 * The $baseClassName class maps the '$tableName' table in database.
 *
 */
class $baseClassName extends TDBM_Object 
{
";
		
		
		foreach ($table->columns as $column) {

			$type = $column->type;
			$normalizedType = $this->dbConnection->getUnderlyingType($type);

			$columnGetterName = self::getGetterNameForPropertyName($column->name);
			$columnSetterName = self::getSetterNameForPropertyName($column->name);
			
			$methodsList[$columnGetterName] = $columnGetterName;
			$methodsList[$columnSetterName] = $columnSetterName;			
			
			if ($normalizedType == "timestamp" || $normalizedType == "datetime" || $normalizedType == "date") {
				$str .= '	/**
	 * The getter for the "'.$column->name.'" column.
	 * It is returned as a PHP timestamp.
	 *
	 * @return timestamp
	 */
	public function '.$columnGetterName.'(){
		return strtotime($this->'.$column->name.');
	}
	
	/**
	 * The setter for the "'.$column->name.'" column.
	 * It must be provided as a PHP timestamp.
	 *
	 * @param timestamp $'.$column->name.'
	 */
	public function '.$columnSetterName.'($'.$column->name.') {
		$this->'.$column->name.' = date("Y-m-d H:i:s", $'.$column->name.');
	}
	
';
			} else {
				$str .= '	/**
	 * The getter for the "'.$column->name.'" column.
	 *
	 * @return string
	 */
	public function '.$columnGetterName.'(){
		return $this->'.$column->name.';
	}
	
	/**
	 * The setter for the "'.$column->name.'" column.
	 *
	 * @param string $'.$column->name.'
	 */
	public function '.$columnSetterName.'($'.$column->name.') {
		$this->'.$column->name.' = $'.$column->name.';
	}
	
';				
			}


		}

		$referencedTablesList = array();
		// Now, let's get the constraints from this table on another table.
		// We will generate getters and setters for those. 
		//$constraints = $this->dbConnection->getConstraintsFromTable($tableName);
		$constraints = $this->dbConnection->getConstraintsOnTable($tableName);
		
		foreach ($constraints as $array) {
			if (!isset($referencedTablesList[$array["table2"]])) {
				$referencedTablesList[$array["table2"]] = 1; 
			} else {
				$referencedTablesList[$array["table2"]] += 1;
			}
			$getterName = self::getGetterNameForConstrainedObject($array["table2"], $array["col1"]);
			$setterName = self::getSetterNameForConstrainedObject($array["table2"], $array["col1"]);
			
			// If the method has already been defined, lets not write it.
			if (isset($methodsList[$getterName]) || isset($methodsList[$setterName])) {
				continue;
			}
			$methodsList[$getterName] = $getterName;
			$methodsList[$setterName] = $setterName; 

			$referencedBeanName = $this->getBeanNameFromTableName($array["table2"]);

			$str .= '	/**
	 * Returns the '.$referencedBeanName.' object bound to this object via the '.$array["col1"].' column.
	 * 
	 * @return '.$referencedBeanName.'
	 */
	public function '.$getterName.'() {
		return $this->tdbmService->getObject("'.$array["table2"].'", $this->'.$array["col1"].', "'.$referencedBeanName.'");
	}
	
	/**
	 * The setter for the "'.$column->name.'" column.
	 *
	 * @param '.$referencedBeanName.' $object
	 */
	public function '.$setterName.'('.$referencedBeanName.' $object) {
		$this->'.$array["col1"].' = $object->'.$array["col2"].';
	}
	
';
				
		}
	
		
		// Now, let's implement the shortcuts to the getter of objects.
		// Shortcuts are used to save typing. They are available only if a referenced table is referenced only once by our tables.
		foreach($referencedTablesList as $referrencedTable=>$number) {
			if ($number == 1) {
				foreach ($constraints as $array) {
					if ($array['table2'] ==$referrencedTable) {
						$columnName = $array['col1'];
						$targetColumnName = $array['col2'];
						break;
					}
				}
				$fullGetterName = self::getGetterNameForConstrainedObject($referrencedTable, $columnName);
				$shortGetterName = self::getGetterNameForConstrainedObject($referrencedTable);
				$fullSetterName = self::getSetterNameForConstrainedObject($referrencedTable, $columnName);
				$shortSetterName = self::getSetterNameForConstrainedObject($referrencedTable);

				// If the method has already been defined, lets not write it.
				if (isset($methodsList[$shortGetterName]) || isset($methodsList[$shortSetterName])) {
					continue;
				}
				$methodsList[$shortGetterName] = $shortGetterName;
				$methodsList[$shortSetterName] = $shortSetterName; 
					
				
				$referencedBeanName = $this->getBeanNameFromTableName($array["table2"]);
				
				$str .= '	/**
	 * Returns the '.$referencedBeanName.' object bound to this object via the '.$array["col1"].' column.
	 * This is an alias for the '.$fullGetterName.' method.  
	 *
	 * @return '.$referencedBeanName.'
	 */
	public function '.$shortGetterName.'() {
		return $this->tdbmService->getObject("'.$array["table2"].'", $this->'.$array["col1"].', "'.$referencedBeanName.'");
	}
	
	/**
	 * The setter for the "'.$array['col1'].'" column.
	 * This is an alias for the '.$fullSetterName.' method.
	 *
	 * @param '.$referencedBeanName.' $object
	 */
	public function '.$shortSetterName.'('.$referencedBeanName.' $object) {
		$this->'.$array["col1"].' = $object->'.$array["col2"].';
	}
	
';
					
			}
		}
		
		$str .= "}
?>";
		
		file_put_contents($directory.$baseFileName, $str);
		

		if (!file_exists($directory.$fileName)) {
			$str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * You can edit this file as it will not be overwritten.
 */

require_once '$baseFileName';
 
/**
 * The $className class maps the '$tableName' table in database.
 *
 */
class $className extends $baseClassName 
{

}";
			file_put_contents($directory.$fileName ,$str);
		}
	}

	/**
	 * Writes the PHP bean DAO with simple functions to create/get/save objects.
	 *
	 * @param string $daoDirectory The directory of the DAOs
	 * @param string $fileName The file that will be written (without the directory)
	 * @param string $className The name of the class
	 * @param string $tableName The name of the table
	 */
	public function generateDao($daoDirectory, $fileName, $baseFileName, $beanFileName, $className, $baseClassName, $beanClassName, $tableName) {

		
		$tableCamel = self::toSingular(self::toCamelCase($tableName));
		
		$str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * DO NOT edit this file, as it might be overwritten.
 * If you need to perform changes, edit the $className class instead!
 */

require_once 'beans/$beanFileName';

/**
 * The $baseClassName class will maintain the persistance of $beanClassName class into the $tableName table.
 * 
 */
class $baseClassName 
{

	/**
	 * @var TDBM_Service
	 */
	protected \$tdbmService;
	
	/**
	 * Sets the TDBM service used by this DAO.
	 *
	 * @Property
	 * @Compulsory
	 * @param TDBM_Service \$tdbmService
	 */
	public function setTdbmService(TDBM_Service \$tdbmService) {
		\$this->tdbmService = \$tdbmService;
	}

	/**
	 * Return a new instance of $beanClassName object, that will be persisted in database.
	 *
	 * @return $beanClassName
	 */
	public function getNew$tableCamel() {
		return \$this->tdbmService->getNewObject('$tableName', true, '$beanClassName');
	}
	
	/**
	 * Persist the $beanClassName instance
	 *
	 */
	public function save$tableCamel($beanClassName \$obj) {
		\$obj->save();
	}
	
	/**
	 * Get all $tableCamel records. 
	 *
	 * @return array<$beanClassName>
	 */
	public function get".$tableCamel."List() {
		return \$this->tdbmService->getObjects('$tableName', null, null, null, null, '$beanClassName');
	}
	
	/**
	 * Get $beanClassName specified by its ID
	 *
	 * @param string \$id
	 * @return $beanClassName
	 */
	public function get".$tableCamel."ById(\$id) {
		return \$this->tdbmService->getObject('$tableName', \$id, '$beanClassName');
	}
	
	/**
	 * Deletes the $beanClassName passed in parameter.
	 *
	 * @param $beanClassName \$obj
	 */
	public function delete".$tableCamel."(\$obj) {
		\$this->tdbmService->deleteObject(\$obj);
	}
}
?>";

		

		file_put_contents($daoDirectory.$baseFileName ,$str);
		
		// Now, let's generate the "editable" class
		if (!file_exists($daoDirectory.$fileName)) {
			$str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * You can edit this file as it will not be overwritten.
 */

require_once '$baseFileName';
 
/**
 * The $className class will maintain the persistance of $beanClassName class into the $tableName table.
 *
 * @Component
 */
class $className extends $baseClassName 
{

}";
			file_put_contents($daoDirectory.$fileName ,$str);
		}
	}
	
	/**
	 * Generates the factory bean.
	 * 
	 * @param $tableList
	 */
	private function generateFactory($tableList) {
		// For each table, let's write a property.
		
		$str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * DO NOT edit this file, as it might be overwritten.
 */
		
/**
 * The $this->daoFactoryClassName provides an easy access to all DAOs generated by TDBM.
 *
 * @Component
 */
class $this->daoFactoryClassName 
{
";

		foreach ($tableList as $table) {
			$daoClassName = $this->getDaoNameFromTableName($table);
			$daoInstanceName = self::toVariableName($daoClassName);
			
			$str .= '	/**
	 * @var '.$daoClassName.'
	 */
	private $'.$daoInstanceName.';

	/**
	 * Returns an instance of the '.$daoClassName.' class.
	 * 
	 * @return '.$daoClassName.'
	 */
	public function get'.$daoClassName.'() {
		return $this->'.$daoInstanceName.';
	}
	
	/**
	 * Sets the instance of the '.$daoClassName.' class that will be returned by the factory getter.
	 * 
	 * @Property
	 * @Compulsory
	 * @param '.$daoClassName.' $'.$daoInstanceName.'
	 */
	public function set'.$daoClassName.'('.$daoClassName.' $'.$daoInstanceName.') {
		$this->'.$daoInstanceName.' = $'.$daoInstanceName.';
	}
	
';
		}
		
		
		$str .= '
}
?>';
		
		$daoDirectory = dirname(__FILE__)."/../../../../../dao/";
		file_put_contents($daoDirectory.$this->daoFactoryClassName.'.php' ,$str);
	}
	
	/**
	 * Transforms the property name in a setter name.
	 * For instance, phone => getPhone or name => getName
	 *
	 * @param string $methodName
	 * @return string
	 */
	public static function getSetterNameForPropertyName($propertyName) {
		$propName2 = self::toCamelCase($propertyName);
		return "set".$propName2;
	}
	
	/**
	 * Transforms the property name in a getter name.
	 * For instance, phone => getPhone or name => getName
	 *
	 * @param string $propertyName
	 * @return string
	 */
	public static function getGetterNameForPropertyName($propertyName) {
		$propName2 = self::toCamelCase($propertyName);
		return "get".$propName2;
	}

	/**
	 * Transforms the table name constrained by this object into a setter name.
	 * For instance, users => setUserByUserId or role => setRoleByRoleId
	 *
	 * @param $tableName The table that is constrained
	 * @param $columnName The column used to constrain the table (optional). If omitted, the "By[columnname]" part of the name will be omitted.
	 * @return string
	 */
	public static function getSetterNameForConstrainedObject($tableName, $columnName = null) {
		$getter = self::toSingular(self::toCamelCase($tableName));
		if ($columnName) {
			$getter .= 'By'.self::toCamelCase($columnName);
		}
		return "set".$getter;
	}
	
	/**
	 * Transforms the table name constrained by this object into a getter name.
	 * For instance, users => getUserByUserId or role => getRoleByRoleId
	 *
	 * @param $tableName The table that is constrained
	 * @param $columnName The column used to constrain the table (optional). If omitted, the "By[columnname]" part of the name will be omitted.
	 * @return string
	 */
	public static function getGetterNameForConstrainedObject($tableName, $columnName = null) {
		$getter = self::toSingular(self::toCamelCase($tableName));
		if ($columnName) {
			$getter .= 'By'.self::toCamelCase($columnName);
		}
		return "get".$getter;
	}
	
	/**
	 * Transforms a string to camelCase (except the first letter will be uppercase too).
	 * Underscores are removed and the first letter after the underscore is uppercased.
	 * 
	 * @param $str string
	 * @return string
	 */
	public static function toCamelCase($str) {
		$str = strtoupper(substr($str,0,1)).substr($str,1);
		while (true) {
			if (strpos($str, "_") === false)
				break;
				
			$pos = strpos($str, "_");
			$before = substr($str,0,$pos);
			$after = substr($str,$pos+1);
			$str = $before.strtoupper(substr($after,0,1)).substr($after,1);
		}
		return $str;
	}
	
	/**
	 * Tries to put string to the singular form (if it is plural).
	 * Obviously, this can't be perfect, be we do the best we can.
	 * 
	 * @param $str string
	 * @return string
	 */
	public static function toSingular($str) {
		// First, ignore "ss" words (like access).
		if (strpos($str, "ss", strlen($str)-2) !== false) {
			return $str;
		}
		
		// Now, let's see if the string ends with s:
		if (strpos($str, "s", strlen($str)-1) !== false) {
			// Yes? Let's remove the s.
			return substr($str, 0, strlen($str)-1);
		}
		return $str;
	}
	
	/**
	 * Put the first letter of the string in lower case.
	 * Very useful to transform a class name into a variable name.
	 * 
	 * @param $str string
	 * @return string
	 */
	public function toVariableName($str) {
		return strtolower(substr($str, 0, 1)).substr($str, 1);
	}
}
?>