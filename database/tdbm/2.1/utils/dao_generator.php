<?php
require_once dirname(__FILE__)."/../../../../../mouf/MoufPackageManager.php";

/**
 * This class generates automatically DAOs and Beans for TDBM.
 *
 */
class TDBMDaoGenerator {

	/**
	 * 
	 * @var DB_ConnectionInterface
	 */
	private $dbConnection;
	
	private $daoFactoryClassName;
	
	/**
	 * The directory for the DAOs, full path with ending /
	 * @var string
	 */
	private $daoDirectory;
	
	/**
	 * The directory for the beans, full path with ending /
	 * @var string
	 */
	private $beanDirectory;
	
	/**
	 * The directory for the beans, relative to ROOT_PATH, without first and trailing /
	 * @var string
	 */
	private $beanRelativeDirectory;
	
	/**
	 * Constructor.
	 *
	 * @param DB_ConnectionInterface $dbConnection The connection to the database.
	 */
	public function __construct(DB_ConnectionInterface $dbConnection, $daoFactoryClassName, $daodirectory, $beandirectory) {
		$this->dbConnection = $dbConnection;
		$this->daoFactoryClassName = $daoFactoryClassName;
		//$this->daodirectory = $daodirectory;
		//$this->beandirectory = $beandirectory;
		$this->beanDirectory = dirname(__FILE__)."/../../../../../".$beandirectory."/";
		$this->daoDirectory = dirname(__FILE__)."/../../../../../".$daodirectory."/";
		$this->beanRelativeDirectory = $beandirectory;
	}
	
	/**
	 * Generates all the daos and beans.
	 */
	public function generateAllDaosAndBeans() {
		// TODO: check that no class name ends with "Base". Otherwise, there will be name clash.
		$tableList = $this->dbConnection->getListOfTables();
		foreach ($tableList as $table) {
			$this->generateDaoAndBean($table);
		}
		
		$this->generateFactory($tableList);

		// Ok, let's return the list of all tables.
		// These will be used by the calling script to create Mouf instances.
		$root = simplexml_load_string("<tdbm></tdbm>");
    	foreach ($tableList as $table) {
    		$root->addChild("table", $table);
    	}
		
		return $root;
	}
	
	/**
	 * Generates in one method call the daos and the beans for one table.
	 * 
	 * @param $tableName
	 */
	public function generateDaoAndBean($tableName) {
		//$baseClassName = TDBMDaoGenerator::toSingular(TDBMDaoGenerator::toCamelCase($tableName));
		$daoName = $this->getDaoNameFromTableName($tableName);
		$beanName = $this->getBeanNameFromTableName($tableName);
		$baseBeanName = $this->getBaseBeanNameFromTableName($tableName);
		
		if (!file_exists($this->daoDirectory)) {
			$result = mkdir($this->daoDirectory, 0777, true);
			if ($result == false) {
				echo "Unable to create directory: ".$this->daoDirectory.".";
				exit;
			}
		}
		if (!file_exists($this->beanDirectory)) {
			$result = mkdir($this->beanDirectory, 0777, true);
			if ($result == false) {
				echo "Unable to create directory: ".$this->beanDirectory.".";
				exit;
			}
		}
		
		$this->generateBean($beanName.".php", $beanName, $baseBeanName.".php", $baseBeanName, $tableName);
		$this->generateDao($daoName.".php", $daoName."Base.php", $beanName.".php", $daoName, $daoName."Base", $beanName, $tableName);
	}
	
	/**
	 * Returns the name of the bean class from the table name.
	 * 
	 * @param $tableName
	 * @return string
	 */
	public function getBeanNameFromTableName($tableName) {
		return TDBMDaoGenerator::toSingular(TDBMDaoGenerator::toCamelCase($tableName))."Bean";
	}
	
	/**
	 * Returns the name of the base bean class from the table name.
	 * 
	 * @param $tableName
	 * @return string
	 */
	public function getDaoNameFromTableName($tableName) {
		return TDBMDaoGenerator::toSingular(TDBMDaoGenerator::toCamelCase($tableName))."Dao";
	}
	
	/**
	 * Returns the name of the DAO class from the table name.
	 * 
	 * @param $tableName
	 * @return string
	 */
	public function getBaseBeanNameFromTableName($tableName) {
		return TDBMDaoGenerator::toSingular(TDBMDaoGenerator::toCamelCase($tableName))."BaseBean";
	}
	
	/**
	 * Writes the PHP bean file with all getters and setters from the table passed in parameter.
	 *
	 * @param string $fileName The file that will be written (name only, no directory)
	 * @param string $className The name of the class
	 * @param string $baseFileName The name of the base class file which contains the base file which will be extended (name only, no directory)
	 * @param string $baseClassName The name of the base class which will be extended (name only, no directory)
	 * @param string $tableName The name of the table
	 */	
	public function generateBean($fileName, $className, $baseFileName, $baseClassName, $tableName) {
		//$tableInfo = $this->dbConnection->getTableInfo($tableName);
		$table = $this->dbConnection->getTableFromDbModel($tableName);

		// List of methods already written.
		$methodsList = array();
		
		$str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * DO NOT edit this file, as it might be overwritten.
 * If you need to perform changes, edit the $className class instead!
 */

/**
 * The $baseClassName class maps the '$tableName' table in database.
 *
 */
class $baseClassName extends TDBM_Object 
{
";
		
		
		foreach ($table->columns as $column) {

			$type = $column->type;
			$normalizedType = $this->dbConnection->getUnderlyingType($type);

			$columnGetterName = self::getGetterNameForPropertyName($column->name);
			$columnSetterName = self::getSetterNameForPropertyName($column->name);
			
			$methodsList[$columnGetterName] = $columnGetterName;
			$methodsList[$columnSetterName] = $columnSetterName;			
			
			if ($normalizedType == "timestamp" || $normalizedType == "datetime" || $normalizedType == "date") {
				$str .= '	/**
	 * The getter for the "'.$column->name.'" column.
	 * It is returned as a PHP timestamp.
	 *
	 * @return timestamp
	 */
	public function '.$columnGetterName.'(){
		return strtotime($this->__get(\''.$column->name.'\'));
	}
	
	/**
	 * The setter for the "'.$column->name.'" column.
	 * It must be provided as a PHP timestamp.
	 *
	 * @param timestamp $'.$column->name.'
	 */
	public function '.$columnSetterName.'($'.$column->name.') {
		$this->__set(\''.$column->name.'\', date("Y-m-d H:i:s", $'.$column->name.'));
	}
	
';
			} else {
				$str .= '	/**
	 * The getter for the "'.$column->name.'" column.
	 *
	 * @return string
	 */
	public function '.$columnGetterName.'(){
		return $this->__get(\''.$column->name.'\');
	}
	
	/**
	 * The setter for the "'.$column->name.'" column.
	 *
	 * @param string $'.$column->name.'
	 */
	public function '.$columnSetterName.'($'.$column->name.') {
		$this->__set(\''.$column->name.'\', $'.$column->name.');
	}
	
';				
			}


		}

		$referencedTablesList = array();
		// Now, let's get the constraints from this table on another table.
		// We will generate getters and setters for those. 
		//$constraints = $this->dbConnection->getConstraintsFromTable($tableName);
		$constraints = $this->dbConnection->getConstraintsOnTable($tableName);
		
		foreach ($constraints as $array) {
			if (!isset($referencedTablesList[$array["table2"]])) {
				$referencedTablesList[$array["table2"]] = 1; 
			} else {
				$referencedTablesList[$array["table2"]] += 1;
			}
			$getterName = self::getGetterNameForConstrainedObject($array["table2"], $array["col1"]);
			$setterName = self::getSetterNameForConstrainedObject($array["table2"], $array["col1"]);
			
			// If the method has already been defined, lets not write it.
			if (isset($methodsList[$getterName]) || isset($methodsList[$setterName])) {
				continue;
			}
			$methodsList[$getterName] = $getterName;
			$methodsList[$setterName] = $setterName; 

			$referencedBeanName = $this->getBeanNameFromTableName($array["table2"]);

			$str .= '	/**
	 * Returns the '.$referencedBeanName.' object bound to this object via the '.$array["col1"].' column.
	 * 
	 * @return '.$referencedBeanName.'
	 */
	public function '.$getterName.'() {
		return $this->tdbmService->getObject("'.$array["table2"].'", $this->'.$array["col1"].', "'.$referencedBeanName.'", true);
	}
	
	/**
	 * The setter for the '.$referencedBeanName.' object bound to this object via the '.$array["col1"].' column.
	 *
	 * @param '.$referencedBeanName.' $object
	 */
	public function '.$setterName.'($object) {
		$this->__set(\''.$array["col1"].'\', ($object == null)?null:$object->__get(\''.$array["col2"].'\'));
	}
	
';
				
		}
	
		
		// Now, let's implement the shortcuts to the getter of objects.
		// Shortcuts are used to save typing. They are available only if a referenced table is referenced only once by our tables.
		foreach($referencedTablesList as $referrencedTable=>$number) {
			if ($number == 1) {
				foreach ($constraints as $array) {
					if ($array['table2'] ==$referrencedTable) {
						$columnName = $array['col1'];
						$targetColumnName = $array['col2'];
						break;
					}
				}
				$fullGetterName = self::getGetterNameForConstrainedObject($referrencedTable, $columnName);
				$shortGetterName = self::getGetterNameForConstrainedObject($referrencedTable);
				$fullSetterName = self::getSetterNameForConstrainedObject($referrencedTable, $columnName);
				$shortSetterName = self::getSetterNameForConstrainedObject($referrencedTable);

				// If the method has already been defined, lets not write it.
				if (isset($methodsList[$shortGetterName]) || isset($methodsList[$shortSetterName])) {
					continue;
				}
				$methodsList[$shortGetterName] = $shortGetterName;
				$methodsList[$shortSetterName] = $shortSetterName; 
					
				
				$referencedBeanName = $this->getBeanNameFromTableName($array["table2"]);
				
				$str .= '	/**
	 * Returns the '.$referencedBeanName.' object bound to this object via the '.$array["col1"].' column.
	 * This is an alias for the '.$fullGetterName.' method.  
	 *
	 * @return '.$referencedBeanName.'
	 */
	public function '.$shortGetterName.'() {
		return $this->tdbmService->getObject("'.$array["table2"].'", $this->'.$array["col1"].', "'.$referencedBeanName.'");
	}
	
	/**
	 * The setter for the "'.$array['col1'].'" column.
	 * This is an alias for the '.$fullSetterName.' method.
	 *
	 * @param '.$referencedBeanName.' $object
	 */
	public function '.$shortSetterName.'($object) {
		$this->__set(\''.$array["col1"].'\', ($object == null)?null:$object->__get(\''.$array["col2"].'\'));
	}
	
';
					
			}
		}
		
		$str .= "}
?>";
		
		file_put_contents($this->beanDirectory.$baseFileName, $str);
		

		if (!file_exists($this->beanDirectory.$fileName)) {
			$str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * You can edit this file as it will not be overwritten.
 */

require_once '$baseFileName';
 
/**
 * The $className class maps the '$tableName' table in database.
 *
 */
class $className extends $baseClassName 
{

}";
			file_put_contents($this->beanDirectory.$fileName ,$str);
		}
	}

	/**
	 * Writes the PHP bean DAO with simple functions to create/get/save objects.
	 *
	 * @param string $fileName The file that will be written (without the directory)
	 * @param string $className The name of the class
	 * @param string $tableName The name of the table
	 */
	public function generateDao($fileName, $baseFileName, $beanFileName, $className, $baseClassName, $beanClassName, $tableName) {

		
		$tableCamel = self::toSingular(self::toCamelCase($tableName));
		
		$str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * DO NOT edit this file, as it might be overwritten.
 * If you need to perform changes, edit the $className class instead!
 */

require_once ROOT_PATH.'$this->beanRelativeDirectory/$beanFileName';

/**
 * The $baseClassName class will maintain the persistance of $beanClassName class into the $tableName table.
 * 
 */
class $baseClassName 
{

	/**
	 * @var TDBM_Service
	 */
	protected \$tdbmService;
	
	/**
	 * Sets the TDBM service used by this DAO.
	 *
	 * @Property
	 * @Compulsory
	 * @param TDBM_Service \$tdbmService
	 */
	public function setTdbmService(TDBM_Service \$tdbmService) {
		\$this->tdbmService = \$tdbmService;
	}

	/**
	 * Return a new instance of $beanClassName object, that will be persisted in database.
	 *
	 * @return $beanClassName
	 */
	public function getNew$tableCamel() {
		return \$this->tdbmService->getNewObject('$tableName', true, '$beanClassName');
	}
	
	/**
	 * Persist the $beanClassName instance
	 *
	 */
	public function save$tableCamel($beanClassName \$obj) {
		\$obj->save();
	}
	
	/**
	 * Get all $tableCamel records. 
	 *
	 * @return array<$beanClassName>
	 */
	public function get".$tableCamel."List() {
		return \$this->tdbmService->getObjects('$tableName', null, null, null, null, '$beanClassName');
	}
	
	/**
	 * Get $beanClassName specified by its ID (its primary key)
	 * If the primary key does not exist, an exception is thrown.
	 *
	 * @param string \$id
	 * @param boolean \$lazyLoading If set to true, the object will not be loaded right away. Instead, it will be loaded when you first try to access a method of the object.
	 * @return $beanClassName
	 * @throws TDBM_Exception
	 */
	public function get".$tableCamel."ById(\$id, \$lazyLoading = false) {
		return \$this->tdbmService->getObject('$tableName', \$id, '$beanClassName', \$lazyLoading);
	}
	
	/**
	 * Deletes the $beanClassName passed in parameter.
	 *
	 * @param $beanClassName \$obj
	 */
	public function delete".$tableCamel."(\$obj) {
		\$this->tdbmService->deleteObject(\$obj);
	}
	
	/**
	 * Get a list of $beanClassName specified by its filters.
	 *
	 * @param mixed \$filterBag The filter bag (see TDBM_Service::getObjects for complete description)
	 * @param mixed \$orderbyBag The order bag (see TDBM_Service::getObjects for complete description)
	 * @param integer \$from The offset
	 * @param integer \$limit The maximum number of rows returned
	 * @return array<$beanClassName>
	 */
	protected function get".$tableCamel."ListByFilter(\$filterBag=null, \$orderbyBag=null, \$from=null, \$limit=null) {
		return \$this->tdbmService->getObjects('$tableName', \$filterBag, \$orderbyBag, \$from, \$limit, '$beanClassName');
	}

	/**
	 * Get a single $beanClassName specified by its filters.
	 *
	 * @param mixed \$filterBag The filter bag (see TDBM_Service::getObjects for complete description)
	 * @return $beanClassName
	 */
	protected function get".$tableCamel."ByFilter(\$filterBag=null) {
		return \$this->tdbmService->getObject('$tableName', \$filterBag, '$beanClassName');
	}
}
?>";

		

		file_put_contents($this->daoDirectory.$baseFileName ,$str);
		
		// Now, let's generate the "editable" class
		if (!file_exists($this->daoDirectory.$fileName)) {
			$str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * You can edit this file as it will not be overwritten.
 */

require_once '$baseFileName';
 
/**
 * The $className class will maintain the persistance of $beanClassName class into the $tableName table.
 *
 * @Component
 */
class $className extends $baseClassName 
{

}";
			file_put_contents($this->daoDirectory.$fileName ,$str);
		}
	}
	
	/**
	 * Generates the factory bean.
	 * 
	 * @param $tableList
	 */
	private function generateFactory($tableList) {
		// For each table, let's write a property.
		
		$str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * DO NOT edit this file, as it might be overwritten.
 */
		
/**
 * The $this->daoFactoryClassName provides an easy access to all DAOs generated by TDBM.
 *
 * @Component
 */
class $this->daoFactoryClassName 
{
";

		foreach ($tableList as $table) {
			$daoClassName = $this->getDaoNameFromTableName($table);
			$daoInstanceName = self::toVariableName($daoClassName);
			
			$str .= '	/**
	 * @var '.$daoClassName.'
	 */
	private $'.$daoInstanceName.';

	/**
	 * Returns an instance of the '.$daoClassName.' class.
	 * 
	 * @return '.$daoClassName.'
	 */
	public function get'.$daoClassName.'() {
		return $this->'.$daoInstanceName.';
	}
	
	/**
	 * Sets the instance of the '.$daoClassName.' class that will be returned by the factory getter.
	 * 
	 * @Property
	 * @Compulsory
	 * @param '.$daoClassName.' $'.$daoInstanceName.'
	 */
	public function set'.$daoClassName.'('.$daoClassName.' $'.$daoInstanceName.') {
		$this->'.$daoInstanceName.' = $'.$daoInstanceName.';
	}
	
';
		}
		
		
		$str .= '
}
?>';
		
		//$daoDirectory = dirname(__FILE__)."/../../../../../dao/";
		file_put_contents($this->daoDirectory.$this->daoFactoryClassName.'.php' ,$str);
	}
	
	/**
	 * Transforms the property name in a setter name.
	 * For instance, phone => getPhone or name => getName
	 *
	 * @param string $methodName
	 * @return string
	 */
	public static function getSetterNameForPropertyName($propertyName) {
		$propName2 = self::toCamelCase($propertyName);
		return "set".$propName2;
	}
	
	/**
	 * Transforms the property name in a getter name.
	 * For instance, phone => getPhone or name => getName
	 *
	 * @param string $propertyName
	 * @return string
	 */
	public static function getGetterNameForPropertyName($propertyName) {
		$propName2 = self::toCamelCase($propertyName);
		return "get".$propName2;
	}

	/**
	 * Transforms the table name constrained by this object into a setter name.
	 * For instance, users => setUserByUserId or role => setRoleByRoleId
	 *
	 * @param $tableName The table that is constrained
	 * @param $columnName The column used to constrain the table (optional). If omitted, the "By[columnname]" part of the name will be omitted.
	 * @return string
	 */
	public static function getSetterNameForConstrainedObject($tableName, $columnName = null) {
		$getter = self::toSingular(self::toCamelCase($tableName));
		if ($columnName) {
			$getter .= 'By'.self::toCamelCase($columnName);
		}
		return "set".$getter;
	}
	
	/**
	 * Transforms the table name constrained by this object into a getter name.
	 * For instance, users => getUserByUserId or role => getRoleByRoleId
	 *
	 * @param $tableName The table that is constrained
	 * @param $columnName The column used to constrain the table (optional). If omitted, the "By[columnname]" part of the name will be omitted.
	 * @return string
	 */
	public static function getGetterNameForConstrainedObject($tableName, $columnName = null) {
		$getter = self::toSingular(self::toCamelCase($tableName));
		if ($columnName) {
			$getter .= 'By'.self::toCamelCase($columnName);
		}
		return "get".$getter;
	}
	
	/**
	 * Transforms a string to camelCase (except the first letter will be uppercase too).
	 * Underscores and spaces are removed and the first letter after the underscore is uppercased.
	 * 
	 * @param $str string
	 * @return string
	 */
	public static function toCamelCase($str) {
		$str = strtoupper(substr($str,0,1)).substr($str,1);
		while (true) {
			if (strpos($str, "_") === false && strpos($str, " ") === false)
				break;
				
			$pos = strpos($str, "_");
			if ($pos === false) {
				$pos = strpos($str, " ");
			}
			$before = substr($str,0,$pos);
			$after = substr($str,$pos+1);
			$str = $before.strtoupper(substr($after,0,1)).substr($after,1);
		}
		return $str;
	}
	
	/**
	 * Tries to put string to the singular form (if it is plural).
	 * Obviously, this can't be perfect, be we do the best we can.
	 * 
	 * @param $str string
	 * @return string
	 */
	public static function toSingular($str) {
		// First, ignore "ss" words (like access).
		if (strpos($str, "ss", strlen($str)-2) !== false) {
			return $str;
		}
		
		// Now, let's see if the string ends with s:
		if (strpos($str, "s", strlen($str)-1) !== false) {
			// Yes? Let's remove the s.
			return substr($str, 0, strlen($str)-1);
		}
		return $str;
	}
	
	/**
	 * Put the first letter of the string in lower case.
	 * Very useful to transform a class name into a variable name.
	 * 
	 * @param $str string
	 * @return string
	 */
	public function toVariableName($str) {
		return strtolower(substr($str, 0, 1)).substr($str, 1);
	}
}
?>