<?php

require_once('DB_Dimension.php');

/**
 * A class specialized in providing aggregated stats for a table using an OLAP like approach.
 * This class provides a way to create automatically a table that will receive aggregated data from a source table.
 * The table will be automatically filled by a trigger on the source table. The trigger is generated by this class too.
 *
 * @Component
 * @ExtendedAction {"name":"Generate stat table", "url":"mouf/dbStatsAdmin/", "default":false}
 * @ExtendedAction {"name":"Recompute stat table", "url":"mouf/dbStatsAdmin/recomputeForm", "default":false}
 */
class DB_Stats {
	
	/**
	 * The connection to the database that contains the table we are working on.
	 * 
	 * @Property
	 * @Compulsory
	 * @var DB_ConnectionInterface
	 */
	public $dbConnection;
	
	/**
	 * The source table that will be used to analyse data from.
	 * 
	 * @Property
	 * @Compulsory
	 * @var string
	 */
	public $sourceTable;
	
	/**
	 * The table in which aggregated stats data will be written.
	 *
	 * @Property
	 * @Compulsory
	 * @var string
	 */
	public $statsTable;
	
	/**
	 * An array containing the dimensions of the target table.
	 * 
	 * @Property
	 * @Compulsory
	 * @var array<DB_Dimension>
	 */
	public $dimensions = array();
	
	
	/**
	 * An array containing the aggregated values of the target table.
	 * 
	 * @Property
	 * @Compulsory
	 * @var array<DB_StatColumn>
	 */
	public $values;
	
	/**
	 * Creates the stats table directly in the database.
	 *
	 * @param boolean $dropIfExist Whether to drop the table if it already exists.
	 */
	public function createStatsTable($dropIfExist = false) {
		
		// TODO: add support for redundant columns in dimensions.
		// Example: "year->month->day->hour" and "hour" can be 2 dimensions

		$table = new DB_Table();
		$table->name = $this->statsTable;
		
		//$columns = array();
		$columnsList = array();
		
		$dbColumn = new DB_Column();
		$dbColumn->name = "ID";
		$dbColumn->type = "BIGINT";
		$dbColumn->nullable = false;
		$dbColumn->autoIncrement = true;
		$dbColumn->isPrimaryKey = true;
		$columnsList["ID"]=1;
		$table->addColumn($dbColumn);
		
		foreach ($this->dimensions as $dimension) {
			foreach ($dimension->columns as $column) {
				// Let's start by registering the column so we don't insert it twice.
				if (isset($columnsList[$column->columnName])) {
					continue;
				}
				$columnsList[$column->columnName] = 1;
				
				$dbColumn = new DB_Column();
				$dbColumn->name = $column->columnName;
				$dbColumn->type = $column->type;
				$dbColumn->nullable = true;
				$dbColumn->default = null;
				$dbColumn->isPrimaryKey = false;
				$table->addColumn($dbColumn);
			}
		}
		
		foreach ($this->values as $column) {
			// Let's start by registering the column so we don't insert it twice.
			if (isset($columnsList[$column->columnName])) {
				continue;
			}
			$columnsList[$column->columnName] = 1;
			
			$dbColumn = new DB_Column();
			$dbColumn->name = $column->columnName;
			$dbColumn->type = $column->type;
			$dbColumn->nullable = false;
			$dbColumn->default = 0;
			$dbColumn->isPrimaryKey = false;
			$table->addColumn($dbColumn);
		}

		
		$this->dbConnection->createTable($table, $dropIfExist);
		
		// Now, let's index the table for any dimension combinaison possible.
		$dimensionCombinations = $this->computeCombinations($this->dimensions);
		
		foreach ($dimensionCombinations as $dimensionCombination) {
			$columnsArr = array();
			foreach ($dimensionCombination as $dimension) {
				foreach ($dimension->columns as $column) {
					$columnsArr[] = $column->columnName;
				}
			}
			
			$this->dbConnection->createIndex($this->statsTable, $columnsArr, true);
		}
			
	}
	
	/**
	 * Creates the triggers that will fill automatically the table.
	 *
	 * @param bool $insertTrigger 
	 * @param bool $updateTrigger
	 * @param bool $deleteTrigger
	 */
	public function createTrigger($insertTrigger=true, $updateTrigger=true, $deleteTrigger=true) {
		// Let's get all the possible combinations of "null" fields according to the dimensions.
		
		$filterColumns = $this->getFilterColumns();
		$columnsArrArr = $this->getNullableColumnsCombinations();
		$valuesArr = $this->getValuesColumns();

		// Ok, now, $columnsArrArr contains a list of list of columns, with all the interesting combinations possible.
		//var_dump($columnsArrArr);
		if ($insertTrigger) {
			
			$trigger_name = "TRG_".$this->sourceTable."_".$this->statsTable."_ONINSERT";
			
			$sql = "DROP TRIGGER IF EXISTS $trigger_name;\n";
			$this->dbConnection->exec($sql);
			$sql = "CREATE TRIGGER $trigger_name AFTER INSERT ON `".$this->sourceTable."` \n";
			$sql .= "  FOR EACH ROW BEGIN \n";
			
			$sql .= "    DECLARE myRowCount int default 0;\n";
			
			foreach ($columnsArrArr as $columns) {

				$sql .= $this->onInsertSqlStatement($columns, $filterColumns, $columnsArrArr, $valuesArr);
				
			}
			
			$sql .= "  END; \n";
			//echo $sql;
			error_log($sql);
			$this->dbConnection->exec($sql);
		}

		// Now for the update trigger
		if ($updateTrigger) {
			
			$trigger_name = "TRG_".$this->sourceTable."_".$this->statsTable."_ONUPDATE";
			
			$sql = "DROP TRIGGER IF EXISTS $trigger_name;\n";
			$this->dbConnection->exec($sql);
			$sql = "CREATE TRIGGER $trigger_name AFTER UPDATE ON `".$this->sourceTable."` \n";
			$sql .= "  FOR EACH ROW BEGIN \n";
			$sql .= "    DECLARE myRowCount int default 0;\n";
						
			foreach ($columnsArrArr as $columns) {
				// First, let's substract the old row
				$sql .= $this->onDeleteSqlStatement($columns, $filterColumns, $columnsArrArr, $valuesArr);
				
				// Then, let's add the new row
				$sql .= $this->onInsertSqlStatement($columns, $filterColumns, $columnsArrArr, $valuesArr);

			}
			
			$sql .= "  END; \n";
			//echo $sql;
			$this->dbConnection->exec($sql);
		}
		
		// Finally, the delete trigger
		if ($deleteTrigger) {
			
			$trigger_name = "TRG_".$this->sourceTable."_".$this->statsTable."_ONDELETE";
			
			$sql = "DROP TRIGGER IF EXISTS $trigger_name;\n";
			$this->dbConnection->exec($sql);
			$sql = "CREATE TRIGGER $trigger_name BEFORE DELETE ON `".$this->sourceTable."` \n";
			$sql .= "  FOR EACH ROW BEGIN \n";
						
			foreach ($columnsArrArr as $columns) {
				// First, let's substract the old row
				$sql .= $this->onDeleteSqlStatement($columns, $filterColumns, $columnsArrArr, $valuesArr);
			}
			
			$sql .= "  END; \n";
			//echo $sql;
			$this->dbConnection->exec($sql);
		}
		
		
	}
	
	/**
	 * Returns the SQL statements that are executed to add ONE line in the stats table, according to the sets of columns passed in parameter.
	 *
	 * @param array<string> $columns
	 * @param unknown_type $filterColumns
	 * @param unknown_type $columnsArrArr
	 * @param unknown_type $valuesArr
	 * @return string the SQL statement.
	 */
	private function onInsertSqlStatement($columns, $filterColumns, $columnsArrArr, $valuesArr) {
		$sql = "    UPDATE `".$this->statsTable."` SET ";
		$updateStrArr = array();
		foreach ($this->values as $value) {
			$updateStrArr[] = $value->columnName."=".$value->columnName."+".$value->getDataOriginForInsertTrigger();
		}
		$sql .= implode(", ", $updateStrArr);
		$sql .= " WHERE ";
		
		$whereStrArr = array();
		// The dimensions
		foreach ($filterColumns as $currentColName=>$currentCol) {
			// $currentCol is the column being set in database. Let's see if we must put NULL or the value....
			if (!isset($columns[$currentColName])) {
				$whereStrArr[] = $currentColName." IS NULL";
			} else {
				$whereStrArr[] = $currentColName." = ".$currentCol->getDataOriginForInsertTrigger();
			}
		}
		$sql .= implode(" AND ", $whereStrArr);
		$sql .= ";\n";
		
		$sql .= "    SELECT ROW_COUNT() INTO myRowCount;\n";
		$sql .= "    IF myRowCount = 0 THEN \n";
		
		$sql .= "      INSERT INTO `".$this->statsTable."` (".implode(", ", array_keys($filterColumns)).",".implode(", ", array_keys($valuesArr)).") VALUES (";
		
		// First the dimensions
		foreach ($filterColumns as $currentColName=>$currentCol) {
			// $currentCol is the column being set in database. Let's see if we must put NULL or the value....
			if (!isset($columns[$currentColName])) {
				$sql .= "NULL, ";
			} else {
				$sql .= $currentCol->getDataOriginForInsertTrigger().", ";
			}
		}
		
		$insertValues = array();
		// Then the values
		foreach ($this->values as $value) {
			$insertValues[] = $value->getDataOriginForInsertTrigger();
		}
		
		$sql .= implode(", ", $insertValues);
		
		$sql .= ");\n";
		
		$sql .= "    END IF;\n";
		return $sql;
	}

	/**
	 * Returns the SQL statements that are executed to remove ONE line in the stats table, according to the sets of columns passed in parameter.
	 *
	 * @param array<string> $columns
	 * @param unknown_type $filterColumns
	 * @param unknown_type $columnsArrArr
	 * @param unknown_type $valuesArr
	 * @return string the SQL statement.
	 */
	private function onDeleteSqlStatement($columns, $filterColumns, $columnsArrArr, $valuesArr) {
		
		$sql = "    UPDATE `".$this->statsTable."` SET ";
		$updateStrArr = array();
		foreach ($this->values as $value) {
			$updateStrArr[] = $value->columnName."=".$value->columnName."-".$value->getDataOriginForUpdateTrigger();
		}
		$sql .= implode(", ", $updateStrArr);
		$sql .= " WHERE ";
		
		$whereStrArr = array();
		// The dimensions
		foreach ($filterColumns as $currentColName=>$currentCol) {
			// $currentCol is the column being set in database. Let's see if we must put NULL or the value....
			if (!isset($columns[$currentColName])) {
				$whereStrArr[] = $currentColName." IS NULL";
			} else {
				$whereStrArr[] = $currentColName." = ".$currentCol->getDataOriginForUpdateTrigger();
			}
		}
		$sql .= implode(" AND ", $whereStrArr);
		$sql .= ";\n";
		
		// Maybe the row is full of "0" values... if this is so, we should delete it!
		$sql .= "    DELETE FROM `".$this->statsTable."` WHERE ".implode(" AND ", $whereStrArr)." AND ";
		$zeroValuesArr = array();
		foreach ($this->values as $value) {
			$zeroValuesArr[] = $value->columnName." = 0";
		}
		$sql .= implode(" AND ", $zeroValuesArr);
		$sql .= ";\n";
		
		return $sql;
	}
	
	/**
	 * Returns an array of array of columns representing all the combinations of columns that can be searched according to the dimensions.
	 * For instance, if we have 2 dimensions: year->month->day, and country->city, it would return an array with those elements:
	 * []
	 * [year],
	 * [year,month],
	 * [year,month,day],
	 * [country]
	 * [year,country]
	 * [year,month,country]
	 * [year,month,day,country] 
	 * [country,city]
	 * [year,country,city]
	 * [year,month,country,city]
	 * [year,month,day,country,city] 
	 *
	 * @return array<array<string>>
	 */
	private function getNullableColumnsCombinations() {
		// For a dimension year->month->day, we can have 4 nullable schemes:
		// null->null ->null
		// year->null ->null
		// year->month->null
		// year->month->day
		
		// This variable contains the list of list of all possible combinations.
		$dimensionsArrArr = array();
				
		// For each dimension, let's comput all those possibilities, separated by commas
		foreach ($this->dimensions as $dimension) {
			$dimensionColumnsArray = array();
			$dimensionColumnsWork = array();
			$dimensionColumnsArray[] = array();
			foreach ($dimension->columns as $column) {
				$dimensionColumnsWork[] = $column->columnName;
				$dimensionColumnsArray[] = $dimensionColumnsWork; //implode(",",$dimensionColumnsWork);
			}
			$dimensionsArrArr[] = $dimensionColumnsArray;
		}
		
		//var_dump($dimensionsArrArr);

		$dimensionsCombinations = $this->computeArrayCombinations($dimensionsArrArr);
		
		//var_dump($dimensionsCombinations);
		
		$columnsArrArr = array();
		
		// Let's flatten the dimensions into one array of columns combinations
		foreach ($dimensionsCombinations as $dimensionArr) {
			$columnsArr = array();
			foreach ($dimensionArr as $arr) {
				$columnsArr = array_merge($columnsArr, $arr);
			}
			// Let's remove duplicate columns if any:
			$columnsArr = array_flip($columnsArr);
			
			$columnsArrArr[] = $columnsArr;
		}
		return $columnsArrArr;
	}
	
	/**
	 * Returns the list of columns that are part of a dimension.
	 * The name of the column is the key of the array, the value is the DB_StatColumn object.
	 *
	 * @return array<string, DB_StatColumn>
	 */
	public function getFilterColumns() {
		// Filter columns: the list of columns that are part of a dimension (the name of the column is stored in the key, the column object in the value)
		$filterColumns = array(); 
		
		// For each dimension, let's comput all those possibilities, separated by commas
		foreach ($this->dimensions as $dimension) {
			foreach ($dimension->columns as $column) {
				$filterColumns[$column->columnName] = $column; 
			}
		}
		return $filterColumns;
	}
	
	/**
	 * Returns an array of columns used as values.
	 * The key is the name of the column, the value is a DB_StatColumn object.
	 *
	 * @return array<string, DB_StatColumn>
	 */
	private function getValuesColumns() {
		$valuesArr = array();
		// Let's get an array of columns for the value part.
		foreach ($this->values as $value) {
			$valuesArr[$value->columnName] = $value;
		}
		return $valuesArr;
	}
	
	/**
	 * This function will run GROUPBY queries to fill the stats table.
	 * It is useful to fill the table the first time, after it is created.
	 * Afterwards, the triggers will keep the table updated.
	 *
	 * @param bool $transactional Whether we should start a transaction to do this or not. Starting a transaction is the only way to ensure safe stats, but can lock the table for quite a long time.
	 */
	public function fillTable($transactional = true) {
		$filterColumns = $this->getFilterColumns();
		$columnsArrArr = $this->getNullableColumnsCombinations();
		$valuesArr = $this->getValuesColumns();
		
		// Let's get the list of all filter columns. Actually, let's remove it from the $columnsArrArr list (this is the last one).
		$allFilterColumns = array_pop($columnsArrArr);
		
		// TODO: start transaction if required.
		
		// Let's purge the table.
		$sql = "TRUNCATE TABLE `".$this->statsTable."`;";
		$this->dbConnection->exec($sql);
		
		// Let's compute the dimensions GROUP BY clause first.
		$filterColArr = array();
		foreach ($filterColumns as $currentColName=>$currentCol) {
			$filterColArr[] = $currentCol->getDataOriginForGroupBy();
		}
		$filterSql = implode(", ", $filterColArr);
		
		$insertValues = array();
		// Then the values
		foreach ($this->values as $value) {
			$insertValues[] = "SUM(".$value->getDataOriginForGroupBy().")";
		}
		
		$valuesSql = implode(", ", $insertValues);
		
		// Now, let's build a huge query to group by all the columns we are interested in.
		$sql = "INSERT INTO `".$this->statsTable."` (".implode(", ", array_keys($allFilterColumns)).",".implode(", ", array_keys($valuesArr)).") ";
		$sql .= "SELECT ".$filterSql.", ";
		
		$sql .= $valuesSql;
		
		$sql .= "FROM `".$this->sourceTable."` ";
		$sql .= "GROUP BY ".$filterSql;
		$sql .= ";";
		
		$this->dbConnection->exec($sql);
		
		// Ok, we filled the stats table with the base data. Now, let's fill it with the NULLs at the right places.
		foreach ($columnsArrArr as $notNullColumns) {
			$sql = "INSERT INTO `".$this->statsTable."` (".implode(", ", array_keys($allFilterColumns)).",".implode(", ", array_keys($valuesArr)).") ";
			$sql .= "SELECT ";
			
			// First the dimensions
			foreach ($filterColumns as $currentColName=>$currentCol) {
				// $currentCol is the column being set in database. Let's see if we must put NULL or the value....
				if (!isset($notNullColumns[$currentColName])) {
					$sql .= "NULL, ";
				} else {
					$sql .= $currentCol->columnName.", ";
				}
			}
			
			$insertValues = array();
			// Then the values
			foreach ($valuesArr as $columnName=>$column) {
				$insertValues[] = "SUM(".$columnName.")";
			}
			
			$sql .= implode(", ", $insertValues);

			$sql .= " FROM `".$this->statsTable."`";
			
			// Where column: let's remove the NULL values
			$sql .= "  WHERE ";
			$whereArray = array();
			foreach ($filterColumns as $currentColName=>$currentCol) {
				$whereArray[] = $currentColName." IS NOT NULL";
			}
			$sql .= implode(" AND ", $whereArray);
			
			if (!empty($notNullColumns)) {
				$sql .= " GROUP BY ";
				$sql .= implode(", ", array_keys($notNullColumns));
			}
			
			//echo $sql."\n";
			$this->dbConnection->exec($sql);
		}
		
		
	}
	
	/**
	 * Returns an array containing all the combinations of all the components in the array
	 *
	 * @param array<obj> $array The array to combine
	 * @return array<array<DB_Dimension>> All the combinations of the elements of the array
	 */
	private function computeCombinations($array) {
		$pop = array_pop($array);
		return $this->computeCombinationsRecurs(array($pop), $array);
	}
	
	/**
	 * Enter description here...
	 *
	 * @param array<DB_Dimension> $combination
	 * @param array<DB_Dimension> $remainingElems
	 * @return array<array<DB_Dimension>> The combinations so far computed
	 */
	private function computeCombinationsRecurs($combination, $remainingElems) {
		if (empty($remainingElems)) {
			return array($combination);
		}
		
		$elem = array_pop($remainingElems);
		
		$combs = array();
		for ($i=0; $i<=count($combination); $i++) {
			$subCombs = $this->computeCombinationsRecurs($this->insertAtPos($combination, $elem, $i), $remainingElems);
			$combs = array_merge($combs, $subCombs);
		}
		
		return $combs;
	}

	/**
	 * Insert at position $i the elem $elem in array $array
	 *
	 * @param array<DB_Dimension> $array
	 * @param DB_Dimension $elem
	 * @param int $i
	 */
	private function insertAtPos($array, $elem, $i) {
		
		if ($i != 0) {
			$beginningArr = array_slice($array, 0, $i);
		} else {
			$beginningArr = array();
		}
		
		if ($i != count($array)) {
			$endArr = array_slice($array, $i);
		} else {
			$endArr = array();
		}
		
		$beginningArr[] = $elem;
		
		return array_merge($beginningArr, $endArr);
	}
	
	
	/**
	 * Compute all the possible combinations of a set of array.
	 * For instance, if you pass to the function [ [a,b,c], [1,2,3], [x,y] ], the function will return
	 * [a,1,x], [a,1,y], [a,2,x]...... 
	 *
	 * @param array<array> $array
	 * @return array<array>
	 */
	public function computeArrayCombinations($array) {
		return $this->computeArrayCombinationsRecurs($array, 0, array());
	}
	
	/**
	 * Compute all the possible combinations of a set of array - Recursive function called by computeArrayCombinations.
	 * For instance, if you pass to the function [ [a,b,c], [1,2,3], [x,y] ], the function will return
	 * [a,1,x], [a,1,y], [a,2,x]...... 
	 *
	 * @param array<array> $array
	 * @param int $k
	 * @param array $buildArr
	 */
	private function computeArrayCombinationsRecurs($array, $k, $buildArr) {
		if ($k == count($array)) {
			return array($buildArr);
		}
		
		$mergedRes = array();
		
		foreach ($array[$k] as $elem) {
			$buildArr2 = $buildArr;
			$buildArr2[] = $elem;
			$resArray = $this->computeArrayCombinationsRecurs($array, $k+1, $buildArr2);
			$mergedRes = array_merge($mergedRes, $resArray);
		}
		
		return $mergedRes;
	}
	
	/**
	 * Sets the connection to the database.
	 *
	 * @param Mouf_DBConnection $dbConnection
	 */
	public function setDbConnection(Mouf_DBConnection $dbConnection) {
		$this->dbConnection = $dbConnection;
	}
	
	/**
	 * Sets the source table.
	 * The source table is the table containing the data we compute statistics on.
	 *
	 * @param string $sourceTable
	 */
	public function setSourceTable($sourceTable) {
		$this->sourceTable = $sourceTable;
	}
	
	/**
	 * Sets the stats table.
	 * The stats table is the table containing the computed statistics.
	 *
	 * @param string $statsTable
	 */
	public function setStatsTable($statsTable) {
		$this->statsTable = $statsTable;
	}
	
	/**
	 * Sets the dimensions as an array of DB_Dimension object.
	 *
	 * @param array<DB_Dimension>
	 */
	public function setDimensions(array $dimensions) {
		$this->dimensions = $dimensions;
	}
	
	/**
	 * Adds a dimension to the list of dimensions.
	 *
	 * @param DB_Dimension $dimension
	 */
	public function addDimension(DB_Dimension $dimension) {
		$this->dimensions[] = $dimension;
	}
	
	/**
	 * Adds a value to the list of values.
	 *
	 * @param DB_StatColumn $value
	 */
	public function addValue(DB_StatColumn $value) {
		$this->values[] = $value;
	}
}
?>